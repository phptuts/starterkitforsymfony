<?php

namespace StarterKit\StartBundle\Repository;

use StarterKit\StartBundle\Entity\BaseUser;
use StarterKit\StartBundle\Exception\ProgrammerException;
use Doctrine\DBAL\Types\Type;
use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\NonUniqueResultException;
use Doctrine\ORM\NoResultException;

/**
 * UserRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UserRepository extends EntityRepository
{
    const PAGE_LIMIT = 10;

    /**
     * This will find one user by it's email, email is unique so it should only return one user.
     *
     * @param $email
     * @return BaseUser|null|object
     */
    public function findUserByEmail($email)
    {
        return $this->findOneBy(['email' => $email]);
    }

    /**
     * Return null or a user
     *
     * @param $id
     * @return null|object|BaseUser
     */
    public function findByFacebookUserId($id)
    {
        return $this->findOneBy(['facebookUserId' => $id]);
    }

    /**
     * Return null or a user
     *
     * @param $id
     * @return null|object|BaseUser
     */
    public function findByGoogleUserId($id)
    {
        return $this->findOneBy(['googleUserId' => $id]);
    }

    /**
     * Returns a user with the right password token.
     * If multiple tokens are found in the db a programmer exception is thrown with a specific code.
     *
     * @param $token
     * @return null|BaseUser
     * @throws ProgrammerException
     */
    public function findUserByForgetPasswordToken($token)
    {
        try {
            $builder = $this->createQueryBuilder('u');

            return $builder->where($builder->expr()->eq('u.forgetPasswordToken', ':token'))
                ->andWhere($builder->expr()->isNotNull('u.forgetPasswordExpired'))
                ->andWhere('u.forgetPasswordExpired >= :today')
                ->setParameter('token', $token)
                ->setParameter('today', new \DateTime(), Type::DATETIME)
                ->getQuery()
                ->getSingleResult();

        } catch (NoResultException $ex) {
            // This means that nothing was found this thrown by the getSingleResult method
            return null;
        } catch (NonUniqueResultException $ex) {
            // this means that there was more then one result found and we have duplicate tokens in our database.
            // Look up the code for the error message in the logs
            throw new ProgrammerException('Duplicate Forget Password Token was found.', ProgrammerException::FORGET_PASSWORD_TOKEN_DUPLICATE_EXCEPTION_CODE);
        }
    }

    /**
     * Gets a paginated list of users
     *
     * @param null $searchString
     * @param int $page
     * @param int $limit
     *
     * @return BaseUser[]
     */
    public function searchUsers($searchString = null, $page, $limit)
    {
        return $this->buildUserSearchQuery($searchString)
            ->getQuery()
            ->setMaxResults($limit)
            ->setFirstResult($limit * ($page - 1))
            ->getResult();
    }

    /**
     * Counts the number of users in the search
     *
     * @param string $searchString
     * @return mixed
     */
    public function countNumberOfUserInSearch($searchString = null)
    {
        $builder = $this->buildUserSearchQuery($searchString);

        return $builder->select($builder->expr()->count('u.id'))
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * Builds
     *
     * @param string $searchString
     * @return \Doctrine\ORM\QueryBuilder
     */
    protected function buildUserSearchQuery($searchString = null)
    {
        $builder = $this->createQueryBuilder('u');

        if (!empty($searchString)) {
            $builder
                ->where($builder->expr()->like('u.email', ':searchString'))
                ->orWhere($builder->expr()->like('u.displayName', ':searchString'))
                ->setParameter('searchString', '%' .$searchString . '%');
        }

        return $builder;
    }

    /**
     * Finds a user by refresh token that is not expired
     *
     * @param $token
     * @return null|object|BaseUser
     */
    public function findUserByValidRefreshToken($token)
    {
        /** @var BaseUser $user */
        $user = $this->findOneBy(['refreshToken' => $token]);

        if (!empty($user) && $user->isRefreshTokenValid()) {
            return $user;
        }

        return null;
    }
}